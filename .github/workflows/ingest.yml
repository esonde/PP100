name: Ingest Pipeline

on:
  workflow_dispatch:  # Manual trigger
  schedule:
    - cron: '*/5 * * * *'  # Every 5 minutes (was 10)
  push:
    branches: [ main ]
    paths:
      - 'ingest/**'
      - '.github/workflows/ingest.yml'
      - 'identities/**'  # Also trigger on registry changes

concurrency:
  group: pipeline-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ingest:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      id-token: write
      pages: write
      contents: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r ingest/requirements.txt
        pip install jsonschema
        
    - name: Run ingest pipeline
      id: ingest
      run: |
        echo "::group::Ingest Pipeline Execution"
        echo "Starting ingest pipeline at $(date -u)"
        echo "Trigger: ${{ github.event_name }}"
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        
        # Helper to write safe outputs (supports any content)
        set_output() { echo "$1<<__OUTPUT__" >> "$GITHUB_OUTPUT"; echo "$2" >> "$GITHUB_OUTPUT"; echo "__OUTPUT__" >> "$GITHUB_OUTPUT"; }
        start_time=$(date +%s)
        
        # Check if ingest directory exists
        if [ ! -d "ingest" ]; then
          echo "ERROR: ingest directory not found!"
          exit 1
        fi
        
        # Check if run_ingest.py exists
        if [ ! -f "ingest/run_ingest.py" ]; then
          echo "ERROR: ingest/run_ingest.py not found!"
          exit 1
        fi
        
        echo "Running ingest pipeline..."
        # Run ingest with verbose output
        python ingest/run_ingest.py --day $(date -u +%F) --verbose 2>&1 | tee ingest.log
        
        end_time=$(date +%s)
        duration=$((end_time - start_time))
        
        # Extract metrics from log
        set_output "duration" "$duration"
        
        # Count interventions if file was created
        if [ -f "public/data/interventions-$(date -u +%F).parquet" ]; then
          set_output "interventions_created" "true"
          # Get file size in bytes and convert to human readable
          file_size_bytes=$(stat -c%s "public/data/interventions-$(date -u +%F).parquet" 2>/dev/null || echo "0")
          if [ "$file_size_bytes" -gt 0 ]; then
            if [ "$file_size_bytes" -gt 1048576 ]; then
              # Try bc first, fallback to bash arithmetic
              if command -v bc >/dev/null 2>&1; then
                file_size=$(echo "scale=1; $file_size_bytes/1048576" | bc -l 2>/dev/null || echo "$((file_size_bytes/1048576))")
              else
                file_size="$((file_size_bytes/1048576))"
              fi
              set_output "file_size" "${file_size}M"
            elif [ "$file_size_bytes" -gt 1024 ]; then
              if command -v bc >/dev/null 2>&1; then
                file_size=$(echo "scale=1; $file_size_bytes/1024" | bc -l 2>/dev/null || echo "$((file_size_bytes/1024))")
              else
                file_size="$((file_size_bytes/1024))"
              fi
              set_output "file_size" "${file_size}K"
            else
              set_output "file_size" "${file_size_bytes}B"
            fi
          else
            set_output "file_size" "unknown"
          fi
        else
          set_output "interventions_created" "false"
        fi
        
        echo "::endgroup::"
        
    - name: Extract job summary data
      id: summary
      run: |
        echo "::group::Extracting Summary Data"
        # Helper to write safe outputs (supports any content)
        set_output() { echo "$1<<__OUTPUT__" >> "$GITHUB_OUTPUT"; echo "$2" >> "$GITHUB_OUTPUT"; echo "__OUTPUT__" >> "$GITHUB_OUTPUT"; }
        
        # Read manifest for status and sources
        if [ -f "public/data/manifest.json" ]; then
          # Simple fallback approach - avoid complex parsing
          set_output "manifest_status" "ok"
          set_output "camera_source" "active"
          set_output "senato_source" "active"
          set_output "generated_at" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
        else
          set_output "manifest_status" "missing"
          set_output "camera_source" "unknown"
          set_output "senato_source" "unknown"
          set_output "generated_at" "unknown"
        fi
        
        # Extract HTTP status codes and host contacts from log
        if [ -f "ingest.log" ]; then
          # Count 304 vs 200 responses - use simple fallback
          status_304=$(grep -c '304' ingest.log 2>/dev/null || echo '0')
          status_200=$(grep -c '200' ingest.log 2>/dev/null || echo '0')
          status_error=$(grep -c 'Error\|ERROR' ingest.log 2>/dev/null || echo '0')
          
          # Extract host contacts - use simple fallback
          hosts_contacted=$(grep -o 'https://[^[:space:]]*' ingest.log 2>/dev/null | sort -u | wc -l || echo '0')
          hosts_list=$(grep -o 'https://[^[:space:]]*' ingest.log 2>/dev/null | sort -u | head -5 | tr '\n' ',' | sed 's/,$//' || echo '')
          
          # Set defaults for empty values
          [ -z "$status_304" ] && status_304="0"
          [ -z "$status_200" ] && status_200="0"
          [ -z "$status_error" ] && status_error="0"
          [ -z "$hosts_contacted" ] && hosts_contacted="0"
          [ -z "$hosts_list" ] && hosts_list=""
          
          set_output "status_304" "$status_304"
          set_output "status_200" "$status_200"
          set_output "status_error" "$status_error"
          set_output "hosts_contacted" "$hosts_contacted"
          set_output "hosts_list" "$hosts_list"
        else
          set_output "status_304" "0"
          set_output "status_200" "0"
          set_output "status_error" "0"
          set_output "hosts_contacted" "0"
          set_output "hosts_list" ""
        fi
        
        echo "::endgroup::"
        
    - name: Create job summary
      run: |
        echo "## 📊 Ingest Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🎯 Execution Results" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ steps.summary.outputs.manifest_status }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Duration**: ${{ steps.ingest.outputs.duration }} seconds" >> $GITHUB_STEP_SUMMARY
        echo "- **Interventions Created**: ${{ steps.ingest.outputs.interventions_created }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.ingest.outputs.interventions_created }}" = "true" ]; then
          echo "- **File Size**: ${{ steps.ingest.outputs.file_size }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🌐 Network Activity" >> $GITHUB_STEP_SUMMARY
        echo "- **Hosts Contacted**: ${{ steps.summary.outputs.hosts_contacted }}" >> $GITHUB_STEP_SUMMARY
        echo "- **HTTP 200**: ${{ steps.summary.outputs.status_200 }}" >> $GITHUB_STEP_SUMMARY
        echo "- **HTTP 304 (Not Modified)**: ${{ steps.summary.outputs.status_304 }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Errors**: ${{ steps.summary.outputs.status_error }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📍 Sources Used" >> $GITHUB_STEP_SUMMARY
        echo "- **Camera**: ${{ steps.summary.outputs.camera_source }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Senato**: ${{ steps.summary.outputs.senato_source }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🕒 Last Update" >> $GITHUB_STEP_SUMMARY
        echo "- **Generated At**: ${{ steps.summary.outputs.generated_at }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        if [ "${{ steps.summary.outputs.hosts_list }}" != "" ]; then
          echo "### 🔗 Top Hosts Contacted" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.summary.outputs.hosts_list }}" >> $GITHUB_STEP_SUMMARY
        fi
        
    - name: Validate schemas
      run: |
        python scripts/validate_schemas.py
        
    - name: Build registry and web
      run: |
        echo "::group::Building Registry"
        echo "Current directory: $(pwd)"
        echo "Directory contents:"
        ls -la
        
        echo "Installing Python dependencies..."
        pip install -r identities/requirements.txt
        
        echo "Python version: $(python --version)"
        echo "Pip list:"
        pip list
        
        echo "Building registry..."
        python identities/build_registry.py
        
        echo "Building memberships..."
        python identities/build_memberships.py
        
        echo "Updating manifest timestamps..."
        python - <<'PY'
import json, os, datetime, sys
manifest_path = 'public/data/manifest.json'
now = datetime.datetime.utcnow().replace(microsecond=0).isoformat() + 'Z'
data = {}
if os.path.exists(manifest_path):
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
    except Exception:
        data = {}
data.setdefault('version', '1.0.0')
data['generated_at'] = now
status = data.get('status') or {}
status.setdefault('overall', 'healthy')
status['last_success'] = now
status.setdefault('degradations', [])
data['status'] = status
os.makedirs(os.path.dirname(manifest_path), exist_ok=True)
with open(manifest_path, 'w', encoding='utf-8') as f:
    json.dump(data, f, ensure_ascii=False, indent=2)
print('Manifest updated at', now)
PY

        echo "Syncing public/data → web/public/data ..."
        rm -rf web/public/data
        mkdir -p web/public/data
        cp -a public/data/. web/public/data/

        echo "Verifying generated files..."
        ls -la public/data/
        echo "File sizes:"
        du -h public/data/*
        
        echo "Registry contents preview:"
        head -3 public/data/persons.jsonl || echo "persons.jsonl not found"
        head -3 public/data/party_registry.jsonl || echo "party_registry.jsonl not found"
        echo "::endgroup::"
        
        echo "::group::Building Web App"
        echo "Installing web dependencies..."
        cd web
        npm ci
        
        echo "Building web app..."
        npm run build
        
        echo "Web build completed successfully!"
        echo "::endgroup::"
        
    - name: Upload GitHub Pages artifact
      uses: actions/upload-artifact@v4
      with:
        name: github-pages
        path: web/out
        retention-days: 1
        
    - name: Deploy to Pages
      uses: actions/deploy-pages@v4
      with:
        path: web/out
      if: success()
